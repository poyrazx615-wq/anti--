# Exploit Mapping and Advisory Module
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field
import json

@dataclass
class Exploit:
    """Exploit data model"""
    cve_id: str
    name: str
    description: str
    severity: str
    cvss_score: float
    exploit_db_id: Optional[str] = None
    metasploit_module: Optional[str] = None
    poc_available: bool = False
    requirements: List[str] = field(default_factory=list)
    affected_versions: List[str] = field(default_factory=list)
    mitigation: str = ""

@dataclass
class VulnerabilityMapping:
    """Vulnerability to exploit mapping"""
    vulnerability_type: str
    common_exploits: List[str]
    tools_required: List[str]
    success_rate: str
    difficulty: str
    time_required: str

class VulnerabilityExploitMapper:
    """Map vulnerabilities to available exploits"""
    
    def __init__(self):
        self.vulnerability_mappings = {}
        self.exploit_database = {}
        self._initialize_mappings()
    
    def _initialize_mappings(self):
        """Initialize vulnerability to exploit mappings"""
        
        self.vulnerability_mappings = {
            "SQL_INJECTION": VulnerabilityMapping(
                vulnerability_type="SQL Injection",
                common_exploits=["Union-based", "Blind SQL", "Time-based", "Error-based"],
                tools_required=["SQLMap", "Manual", "Burp Suite"],
                success_rate="95%",
                difficulty="Low-Medium",
                time_required="5-30 minutes"
            ),
            "XSS": VulnerabilityMapping(
                vulnerability_type="Cross-Site Scripting",
                common_exploits=["Reflected XSS", "Stored XSS", "DOM XSS"],
                tools_required=["BeEF", "XSSer", "Manual"],
                success_rate="90%",
                difficulty="Low",
                time_required="5-15 minutes"
            ),
            "RCE": VulnerabilityMapping(
                vulnerability_type="Remote Code Execution",
                common_exploits=["Command Injection", "Code Injection", "Deserialization"],
                tools_required=["Metasploit", "Manual", "Custom Scripts"],
                success_rate="85%",
                difficulty="Medium-High",
                time_required="10-60 minutes"
            ),
            "LFI": VulnerabilityMapping(
                vulnerability_type="Local File Inclusion",
                common_exploits=["Path Traversal", "Log Poisoning", "PHP Wrappers"],
                tools_required=["Manual", "Fimap", "Burp Suite"],
                success_rate="80%",
                difficulty="Medium",
                time_required="10-30 minutes"
            ),
            "XXE": VulnerabilityMapping(
                vulnerability_type="XML External Entity",
                common_exploits=["File Disclosure", "SSRF", "DoS"],
                tools_required=["Manual", "XXEinjector"],
                success_rate="75%",
                difficulty="Medium-High",
                time_required="15-45 minutes"
            ),
            "SSRF": VulnerabilityMapping(
                vulnerability_type="Server-Side Request Forgery",
                common_exploits=["Internal Port Scan", "Cloud Metadata", "Internal Services"],
                tools_required=["SSRFmap", "Manual", "Burp Suite"],
                success_rate="70%",
                difficulty="Medium-High",
                time_required="20-60 minutes"
            ),
            "AUTH_BYPASS": VulnerabilityMapping(
                vulnerability_type="Authentication Bypass",
                common_exploits=["SQL Injection", "Logic Flaws", "Session Fixation"],
                tools_required=["SQLMap", "Hydra", "Manual"],
                success_rate="60%",
                difficulty="Medium",
                time_required="15-45 minutes"
            ),
            "IDOR": VulnerabilityMapping(
                vulnerability_type="Insecure Direct Object Reference",
                common_exploits=["Parameter Manipulation", "UUID Enumeration"],
                tools_required=["Burp Suite", "Manual", "Autorize"],
                success_rate="85%",
                difficulty="Low",
                time_required="5-20 minutes"
            ),
            "CSRF": VulnerabilityMapping(
                vulnerability_type="Cross-Site Request Forgery",
                common_exploits=["Form Submission", "State Change", "Data Modification"],
                tools_required=["Burp Suite", "Manual", "CSRFTester"],
                success_rate="80%",
                difficulty="Low-Medium",
                time_required="10-30 minutes"
            ),
            "FILE_UPLOAD": VulnerabilityMapping(
                vulnerability_type="Unrestricted File Upload",
                common_exploits=["Web Shell Upload", "XSS via SVG", "XXE via XML"],
                tools_required=["Manual", "Weevely", "Burp Suite"],
                success_rate="75%",
                difficulty="Medium",
                time_required="10-30 minutes"
            )
        }
    
    def get_exploit_mapping(self, vulnerability_type: str) -> Optional[VulnerabilityMapping]:
        """Get exploit mapping for vulnerability type"""
        return self.vulnerability_mappings.get(vulnerability_type)
    
    def get_recommended_tools(self, vulnerabilities: List[str]) -> List[str]:
        """Get recommended tools for given vulnerabilities"""
        tools = set()
        for vuln in vulnerabilities:
            mapping = self.get_exploit_mapping(vuln)
            if mapping:
                tools.update(mapping.tools_required)
        return list(tools)
    
    def estimate_exploitation_time(self, vulnerabilities: List[str]) -> str:
        """Estimate total exploitation time"""
        total_minutes = 0
        for vuln in vulnerabilities:
            mapping = self.get_exploit_mapping(vuln)
            if mapping:
                # Parse time range and take average
                time_parts = mapping.time_required.replace(" minutes", "").split("-")
                if len(time_parts) == 2:
                    avg_time = (int(time_parts[0]) + int(time_parts[1])) / 2
                    total_minutes += avg_time
        
        if total_minutes < 60:
            return f"{int(total_minutes)} minutes"
        else:
            hours = int(total_minutes / 60)
            minutes = int(total_minutes % 60)
            return f"{hours} hours {minutes} minutes"

class ExploitAdvisor:
    """Provide exploit recommendations and attack strategies"""
    
    def __init__(self):
        self.mapper = VulnerabilityExploitMapper()
        self.attack_chains = {}
        self._initialize_attack_chains()
    
    def _initialize_attack_chains(self):
        """Initialize common attack chains"""
        
        self.attack_chains = {
            "web_application_takeover": [
                {"step": 1, "action": "SQL Injection", "goal": "Database access"},
                {"step": 2, "action": "Extract credentials", "goal": "Admin access"},
                {"step": 3, "action": "File upload", "goal": "Web shell"},
                {"step": 4, "action": "Privilege escalation", "goal": "System access"}
            ],
            "network_compromise": [
                {"step": 1, "action": "Port scanning", "goal": "Service discovery"},
                {"step": 2, "action": "Vulnerability scanning", "goal": "Find weaknesses"},
                {"step": 3, "action": "Exploitation", "goal": "Initial access"},
                {"step": 4, "action": "Lateral movement", "goal": "Network control"}
            ],
            "data_exfiltration": [
                {"step": 1, "action": "Initial access", "goal": "Foothold"},
                {"step": 2, "action": "Reconnaissance", "goal": "Find data"},
                {"step": 3, "action": "Data collection", "goal": "Stage data"},
                {"step": 4, "action": "Exfiltration", "goal": "Extract data"}
            ]
        }
    
    def recommend_exploits(self, vulnerabilities: List[str]) -> Dict[str, Any]:
        """Recommend exploits based on vulnerabilities"""
        
        recommendations = {
            "vulnerabilities": vulnerabilities,
            "exploits": [],
            "tools": self.mapper.get_recommended_tools(vulnerabilities),
            "estimated_time": self.mapper.estimate_exploitation_time(vulnerabilities),
            "attack_chain": self._generate_attack_chain(vulnerabilities),
            "priority": self._prioritize_vulnerabilities(vulnerabilities)
        }
        
        for vuln in vulnerabilities:
            mapping = self.mapper.get_exploit_mapping(vuln)
            if mapping:
                recommendations["exploits"].append({
                    "vulnerability": vuln,
                    "type": mapping.vulnerability_type,
                    "methods": mapping.common_exploits,
                    "success_rate": mapping.success_rate,
                    "difficulty": mapping.difficulty
                })
        
        return recommendations
    
    def _generate_attack_chain(self, vulnerabilities: List[str]) -> List[Dict]:
        """Generate attack chain based on vulnerabilities"""
        
        chain = []
        step = 1
        
        # Initial access
        if "SQL_INJECTION" in vulnerabilities or "RCE" in vulnerabilities:
            chain.append({
                "step": step,
                "phase": "Initial Access",
                "method": "Exploit SQL Injection or RCE",
                "tools": ["SQLMap", "Metasploit"],
                "duration": "10-30 minutes"
            })
            step += 1
        
        # Privilege escalation
        if "LFI" in vulnerabilities or "FILE_UPLOAD" in vulnerabilities:
            chain.append({
                "step": step,
                "phase": "Privilege Escalation",
                "method": "Upload web shell or read sensitive files",
                "tools": ["Custom Scripts", "Weevely"],
                "duration": "15-30 minutes"
            })
            step += 1
        
        # Persistence
        if "AUTH_BYPASS" in vulnerabilities:
            chain.append({
                "step": step,
                "phase": "Persistence",
                "method": "Create backdoor accounts",
                "tools": ["Manual"],
                "duration": "10-20 minutes"
            })
            step += 1
        
        # Data exfiltration
        chain.append({
            "step": step,
            "phase": "Data Exfiltration",
            "method": "Extract sensitive data",
            "tools": ["Custom Scripts", "Netcat"],
            "duration": "20-60 minutes"
        })
        
        return chain
    
    def _prioritize_vulnerabilities(self, vulnerabilities: List[str]) -> List[str]:
        """Prioritize vulnerabilities by severity and exploitability"""
        
        priority_scores = {
            "RCE": 10,
            "SQL_INJECTION": 9,
            "AUTH_BYPASS": 8,
            "FILE_UPLOAD": 7,
            "XXE": 6,
            "SSRF": 5,
            "LFI": 4,
            "XSS": 3,
            "IDOR": 2,
            "CSRF": 1
        }
        
        return sorted(vulnerabilities, key=lambda x: priority_scores.get(x, 0), reverse=True)
    
    def generate_exploit_report(self, vulnerabilities: List[str]) -> Dict[str, Any]:
        """Generate comprehensive exploit report"""
        
        recommendations = self.recommend_exploits(vulnerabilities)
        
        report = {
            "executive_summary": {
                "total_vulnerabilities": len(vulnerabilities),
                "critical_count": sum(1 for v in vulnerabilities if v in ["RCE", "SQL_INJECTION", "AUTH_BYPASS"]),
                "estimated_compromise_time": recommendations["estimated_time"],
                "required_skill_level": self._assess_skill_level(vulnerabilities)
            },
            "detailed_findings": recommendations["exploits"],
            "attack_strategy": {
                "recommended_sequence": recommendations["priority"],
                "attack_chain": recommendations["attack_chain"],
                "required_tools": recommendations["tools"]
            },
            "mitigation_recommendations": self._generate_mitigations(vulnerabilities)
        }
        
        return report
    
    def _assess_skill_level(self, vulnerabilities: List[str]) -> str:
        """Assess required skill level for exploitation"""
        
        if any(v in ["RCE", "XXE", "SSRF"] for v in vulnerabilities):
            return "Advanced"
        elif any(v in ["SQL_INJECTION", "LFI", "AUTH_BYPASS"] for v in vulnerabilities):
            return "Intermediate"
        else:
            return "Beginner"
    
    def _generate_mitigations(self, vulnerabilities: List[str]) -> List[Dict]:
        """Generate mitigation recommendations"""
        
        mitigations = []
        
        mitigation_map = {
            "SQL_INJECTION": "Use parameterized queries and input validation",
            "XSS": "Implement output encoding and Content Security Policy",
            "RCE": "Sanitize user input and use secure coding practices",
            "LFI": "Validate file paths and use whitelisting",
            "XXE": "Disable XML external entity processing",
            "SSRF": "Implement URL whitelisting and network segmentation",
            "AUTH_BYPASS": "Implement strong authentication mechanisms",
            "IDOR": "Implement proper access controls",
            "CSRF": "Use anti-CSRF tokens",
            "FILE_UPLOAD": "Validate file types and scan uploads"
        }
        
        for vuln in vulnerabilities:
            if vuln in mitigation_map:
                mitigations.append({
                    "vulnerability": vuln,
                    "mitigation": mitigation_map[vuln],
                    "priority": "High" if vuln in ["RCE", "SQL_INJECTION", "AUTH_BYPASS"] else "Medium"
                })
        
        return mitigations

# Create default instances
exploit_mapper = VulnerabilityExploitMapper()
exploit_advisor = ExploitAdvisor()
